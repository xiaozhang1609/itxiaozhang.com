---
title: æ‰¹é‡æ–°å»ºæ–‡ä»¶å¤¹çš„ä¸‰ç§ç®€ä¾¿æ–¹æ³•
permalink: /batch-create-folders/
date: 2025-08-20 23:19:53
description: æœ¬æ–‡ä»‹ç»ä¸‰ç§æ‰¹é‡åˆ›å»ºæ–°æ–‡ä»¶å¤¹çš„æ–¹æ³•ï¼šå·§å¦™é«˜æ•ˆçš„ ChatGPT æŠ€å·§ã€ä¾¿æ·å®ç”¨çš„åœ¨çº¿å·¥å…·ï¼Œä»¥åŠåŠŸèƒ½å¼ºå¤§çš„ Python è„šæœ¬ã€‚
category:
- ç¼–ç¨‹å¼€å‘
tags:
- æ‰¹é‡
- python
- chatgpt
---

> åŸæ–‡åœ°å€ï¼š<https://itxiaozhang.com/batch-create-folders/>  
> å¦‚æœæ‚¨éœ€è¦è¿œç¨‹ç”µè„‘ç»´ä¿®æˆ–è€…ç¼–ç¨‹å¼€å‘ï¼Œè¯·[åŠ æˆ‘å¾®ä¿¡](https://itxiaozhang.netlify.app/)å’¨è¯¢ã€‚ 

## ğŸ“Œ å¸¸è§åœºæ™¯

1. **å‘˜å·¥èµ„æ–™**ï¼šå…¬å¸æ–°å…¥èŒ 200 åå‘˜å·¥ï¼Œéœ€è¦æ‰¹é‡ç”Ÿæˆä¸ªäººèµ„æ–™æ–‡ä»¶å¤¹ã€‚
2. **å­¦ç”Ÿä½œä¸š**ï¼šæŸç­çº§ 60 åå­¦ç”Ÿä¸Šäº¤ä½œä¸šï¼Œè€å¸ˆæŒ‰èŠ±åå†Œæ‰¹é‡ç”Ÿæˆä½œä¸šæ–‡ä»¶å¤¹ã€‚
3. **é¡¹ç›®æˆå‘˜**ï¼šä¸€ä¸ªè·¨éƒ¨é—¨é¡¹ç›®ç»„æœ‰ 50 åæˆå‘˜ï¼Œé¡¹ç›®ç»ç†ä¸ºå…¶æ‰¹é‡åˆ›å»ºä»»åŠ¡èµ„æ–™æ–‡ä»¶å¤¹ã€‚

---

## ğŸ’¡ ä¸ºä»€ä¹ˆè¦æ‰¹é‡åˆ›å»ºæ–‡ä»¶å¤¹

æ‰‹åŠ¨é€ä¸ªæ–°å»ºæ—¢è€—æ—¶åˆå®¹æ˜“å‡ºé”™ã€‚
æ— è®ºæ˜¯ä¸º 20 ä¸ªéƒ¨é—¨å»ºæ–‡ä»¶å¤¹ï¼Œè¿˜æ˜¯æ•´ç† 100 å¼ ç…§ç‰‡ï¼Œé‡å¤æ“ä½œéƒ½ä¼šæµªè´¹æ—¶é—´ã€‚
æ‰¹é‡æ–¹å¼å¯èŠ‚çœçº¦ **90% æ—¶é—´**ï¼Œè®©ä½ ä¸“æ³¨æ›´é‡è¦çš„å·¥ä½œã€‚

---

## æ–¹æ³•ä¸€ï¼šChatGPT å¸®å¿™

å°†ä»¥ä¸‹ä»£ç ç²˜è´´ç»™ ChatGPTï¼Œè®©å…¶æ‰§è¡Œï¼š

```python
# è¯·ä½œä¸ºPythonè§£é‡Šå™¨è¿è¡Œä»¥ä¸‹ä»£ç 
import zipfile
import os

# æ–‡ä»¶å¤¹å’Œæ–‡ä»¶ååˆ—è¡¨ï¼Œå¯ä»¥å¢åŠ æˆ–è€…æ›¿æ¢æ›´å¤š
names = """å”åƒ§
å­™æ‚Ÿç©º
çŒªå…«æˆ’
æ²™å’Œå°š
ç™½é¾™é©¬
ç‰çš‡å¤§å¸
ç‹æ¯å¨˜å¨˜
å¤ªä¸Šè€å›
å¤ªç™½é‡‘æ˜Ÿ
æ‰˜å¡”æå¤©ç‹
å“ªå’ä¸‰å¤ªå­
äºŒéƒç¥
å››å¤§å¤©ç‹
å·¨çµç¥
äºŒåå…«å®¿
é›·å…¬
ç”µæ¯
é£ä¼¯
é›¨å¸ˆ
èµ¤è„šå¤§ä»™
ç¦ç¦„å¯¿ä¸‰æ˜Ÿ
é•‡å…ƒå­
å¦‚æ¥ä½›ç¥–
è§‚éŸ³è©è¨
æ–‡æ®Šè©è¨
æ™®è´¤è©è¨
åœ°è—ç‹è©è¨
å¼¥å‹’ä½›
ç‡ƒç¯å¤ä½›
åå…«ç½—æ±‰
é˜¿å‚©
ä¼½å¶
å¯…å°†å†›
ç†Šå±±å›
ç‰¹å¤„å£«
ç™½éª¨ç²¾
é»„è¢æ€ª
é‡‘è§’å¤§ç‹
é“¶è§’å¤§ç‹
ä¹å°¾ç‹ç‹¸
ç‹®çŒæ€ª
çº¢å­©å„¿
é¼é¾™
è™åŠ›å¤§ä»™
é¹¿åŠ›å¤§ä»™
ç¾ŠåŠ›å¤§ä»™
çµæ„Ÿå¤§ç‹
ç‹¬è§’å…•å¤§ç‹
èå­ç²¾
å…­è€³çŒ•çŒ´
é“æ‰‡å…¬ä¸»
ç‰›é­”ç‹
ç‰é¢ç‹ç‹¸
ä¸‡åœ£é¾™ç‹
ä¹å¤´è™«
é»„çœ‰è€ç¥–
èŸ’è›‡ç²¾
èµ›å¤ªå²
èœ˜è››ç²¾
ç™¾çœ¼é­”å›
é’ç‹®
ç™½è±¡
å¤§é¹é‡‘ç¿…é›•
ç™½é¹¿ç²¾
ç™½é¢ç‹ç‹¸
åœ°æ¶Œå¤«äºº
å—å±±å¤§ç‹
é»„ç‹®ç²¾
ä¹çµå…ƒåœ£
è¾Ÿå¯’å¤§ç‹
è¾Ÿæš‘å¤§ç‹
è¾Ÿå°˜å¤§ç‹
ç‰å…”ç²¾
æ··ä¸–é­”ç‹
é»‘ç†Šç²¾
å‡Œè™šå­
ç™½è¡£ç§€å£«
è™å…ˆé”‹
é»„é£æ€ª
ç²¾ç»†é¬¼
ä¼¶ä¿è™«
å·´å±±è™
å€šæµ·é¾™
ç‹é˜¿ä¸ƒå¤§ç‹
å®è±¡å›½å›½ç‹
ç™¾èŠ±ç¾å…¬ä¸»
ä¹Œé¸¡å›½å›½ç‹
è½¦è¿Ÿå›½å›½ç‹
å¥³å„¿å›½å›½ç‹
æœ±ç´«å›½å›½ç‹
æ¯”ä¸˜å›½å›½ç‹
ç­æ³•å›½å›½ç‹
å¯‡å‘˜å¤–
é™ˆå…‰è•Š
æ®·æ¸©å¨‡
åˆ˜ä¼¯é’¦
é«˜å¤ªå…¬
é«˜ç¿ å…°
å”å¤ªå®—
æä¸–æ°‘
æˆ¿ç„é¾„
æœå¦‚æ™¦
å¾èŒ‚å…¬""".splitlines()

base_dir = "/mnt/data/named_folders"
zip_filename = "/mnt/data/named_folders.zip"

# åˆ›å»ºæ–‡ä»¶å¤¹
os.makedirs(base_dir, exist_ok=True)
for name in names:
    os.makedirs(os.path.join(base_dir, name), exist_ok=True)

# å‹ç¼©æ–‡ä»¶å¤¹
with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            file_path = os.path.join(root, file)
            zipf.write(file_path, os.path.relpath(file_path, base_dir))
        for dir in dirs:
            dir_path = os.path.join(root, dir)
            zipf.write(dir_path, os.path.relpath(dir_path, base_dir))

zip_filename
```

---

## æ–¹æ³•äºŒï¼šçº¯å‰ç«¯åœ¨çº¿å·¥å…·

### ç‰¹ç‚¹

* **æ— éœ€å®‰è£…**ï¼šç½‘é¡µç›´æ¥ç”¨ï¼Œæ–‡ä»¶ä¸ä¸Šä¼ æœåŠ¡å™¨ã€‚
* **æ“ä½œç®€å•**ï¼šä¸Šä¼ åå• â†’ ä¸€é”®ç”Ÿæˆå‹ç¼©åŒ…ã€‚
* **æ™ºèƒ½å¤„ç†**ï¼šè‡ªåŠ¨å»é™¤ç©ºè¡Œä¸éæ³•å­—ç¬¦ã€‚

### ä½¿ç”¨æ­¥éª¤

1. å‡†å¤‡æ–‡æœ¬æ–‡ä»¶ï¼Œæ¯è¡Œä¸€ä¸ªåç§°ã€‚
2. æ‰“å¼€ [æ‰¹é‡æ–‡ä»¶å¤¹ç”Ÿæˆå™¨](https://v0-user-can-you-help-me-understand-lake.vercel.app/)
3. ä¸Šä¼ æ–‡ä»¶å¹¶é¢„è§ˆã€‚
4. ç‚¹å‡» **ç”Ÿæˆ ZIP** â†’ ä¸‹è½½ â†’ è§£å‹å³å¯ã€‚

### æ ¸å¿ƒä»£ç 

```tsx
"use client"

import type React from "react"

import { useState, useCallback } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { Upload, Download, FileText, Folder, AlertCircle, CheckCircle2, X } from "lucide-react"
import { useToast } from "@/hooks/use-toast"
import JSZip from "jszip"

interface ProcessedFile {
  name: string
  content: string[]
  status: "pending" | "processing" | "completed" | "error"
  error?: string
}

export default function FolderGenerator() {
  const [files, setFiles] = useState<ProcessedFile[]>([])
  const [isProcessing, setIsProcessing] = useState(false)
  const [progress, setProgress] = useState(0)
  const { toast } = useToast()

  const handleFileUpload = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const uploadedFiles = Array.from(event.target.files || [])

      if (uploadedFiles.length === 0) return

      const newFiles: ProcessedFile[] = uploadedFiles.map((file) => ({
        name: file.name,
        content: [],
        status: "pending",
      }))

      setFiles((prev) => [...prev, ...newFiles])

      uploadedFiles.forEach((file, index) => {
        const reader = new FileReader()
        reader.onload = (e) => {
          try {
            const content = e.target?.result as string
            const lines = content
              .split(/\r?\n/)
              .map((line) => line.trim())
              .filter((line) => line.length > 0)
              .filter((line) => /^[\u4e00-\u9fa5a-zA-Z0-9\s\-_()ï¼ˆï¼‰]+$/.test(line))

            setFiles((prev) =>
              prev.map((f, i) =>
                i === prev.length - uploadedFiles.length + index
                  ? { ...f, content: lines, status: "completed" as const }
                  : f,
              ),
            )

            toast({
              title: "è§£ææˆåŠŸ",
              description: `${file.name} å…± ${lines.length} ä¸ªæœ‰æ•ˆåç§°`,
            })
          } catch (error) {
            setFiles((prev) =>
              prev.map((f, i) =>
                i === prev.length - uploadedFiles.length + index
                  ? { ...f, status: "error" as const, error: "è§£æå¤±è´¥" }
                  : f,
              ),
            )

            toast({
              title: "è§£æå¤±è´¥",
              description: `${file.name} è§£æé”™è¯¯`,
              variant: "destructive",
            })
          }
        }
        reader.readAsText(file, "utf-8")
      })
    },
    [toast],
  )

  const removeFile = useCallback((index: number) => {
    setFiles((prev) => prev.filter((_, i) => i !== index))
  }, [])

  const generateZip = useCallback(async () => {
    const validFiles = files.filter((f) => f.status === "completed" && f.content.length > 0)

    if (validFiles.length === 0) {
      toast({
        title: "æ— æœ‰æ•ˆæ–‡ä»¶",
        description: "è¯·ä¸Šä¼ æœ‰æ•ˆæ–‡æœ¬æ–‡ä»¶",
        variant: "destructive",
      })
      return
    }

    setIsProcessing(true)
    setProgress(0)

    try {
      const zip = new JSZip()
      let totalItems = 0
      let processedItems = 0

      validFiles.forEach((file) => {
        totalItems += file.content.length
      })

      for (const file of validFiles) {
        const baseName = file.name.replace(/\.[^/.]+$/, "")
        const fileFolder = zip.folder(baseName)

        if (fileFolder) {
          for (const name of file.content) {
            const folderName = name.replace(/[<>:"/\\|?*]/g, "_")
            const nameFolder = fileFolder.folder(folderName)
            if (nameFolder) {
              nameFolder.file("README.txt", `æ–‡ä»¶å¤¹: ${name}\nåˆ›å»ºæ—¶é—´: ${new Date().toLocaleString("zh-CN")}`)
            }

            processedItems++
            setProgress((processedItems / totalItems) * 100)

            await new Promise((resolve) => setTimeout(resolve, 10))
          }
        }
      }

      const content = await zip.generateAsync({ type: "blob" })
      const url = URL.createObjectURL(content)
      const a = document.createElement("a")
      a.href = url
      a.download = `folders_${new Date().toISOString().slice(0, 10)}.zip`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      toast({
        title: "ç”ŸæˆæˆåŠŸ",
        description: `å·²ç”Ÿæˆ ${totalItems} ä¸ªæ–‡ä»¶å¤¹`,
      })
    } catch (error) {
      toast({
        title: "ç”Ÿæˆå¤±è´¥",
        description: "ZIPæ–‡ä»¶ç”Ÿæˆé”™è¯¯",
        variant: "destructive",
      })
    } finally {
      setIsProcessing(false)
      setProgress(0)
    }
  }, [files, toast])

  const totalFolders = files.reduce((sum, file) => sum + (file.content?.length || 0), 0)

  return (
    <div className="min-h-screen bg-white dark:bg-gray-900">
      <div className="container mx-auto px-6 py-12 max-w-3xl">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-bold text-gray-900 dark:text-white mb-3 tracking-tight">æ–‡ä»¶å¤¹ç”Ÿæˆå™¨</h1>
          <p className="text-gray-600 dark:text-gray-400 text-lg">æ‰¹é‡ç”Ÿæˆæ–‡ä»¶å¤¹ç»“æ„</p>
        </div>

        <Card className="mb-8 border-2">
          <CardContent className="pt-8">
            <div className="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center hover:border-gray-400 transition-colors">
              <input
                type="file"
                multiple
                accept=".txt,.csv,.text"
                onChange={handleFileUpload}
                className="hidden"
                id="file-upload"
              />
              <label htmlFor="file-upload" className="cursor-pointer">
                <Upload className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <p className="font-semibold text-gray-700 dark:text-gray-300 mb-2 text-lg">é€‰æ‹©æ–‡ä»¶</p>
                <p className="text-gray-500 dark:text-gray-400">æ”¯æŒ .txt, .csv æ ¼å¼</p>
              </label>
            </div>
          </CardContent>
        </Card>

        {files.length > 0 && (
          <Card className="mb-8 border-2">
            <CardHeader className="pb-4">
              <div className="flex items-center justify-between">
                <CardTitle className="text-xl font-bold">æ–‡ä»¶åˆ—è¡¨ ({files.length})</CardTitle>
                <Badge variant="secondary" className="text-sm px-3 py-1">
                  {totalFolders} ä¸ªæ–‡ä»¶å¤¹
                </Badge>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {files.map((file, index) => (
                <div key={index} className="space-y-3">
                  <div className="flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border">
                    <div className="flex items-center gap-3">
                      {file.status === "completed" && <CheckCircle2 className="h-5 w-5 text-green-600" />}
                      {file.status === "error" && <AlertCircle className="h-5 w-5 text-red-600" />}
                      {file.status === "pending" && <FileText className="h-5 w-5 text-gray-400" />}

                      <div>
                        <p className="font-semibold">{file.name}</p>
                        {file.status === "completed" && (
                          <p className="text-sm text-gray-600 dark:text-gray-400">{file.content.length} ä¸ªåç§°</p>
                        )}
                        {file.status === "error" && <p className="text-sm text-red-600">{file.error}</p>}
                      </div>
                    </div>

                    <Button variant="ghost" size="sm" onClick={() => removeFile(index)}>
                      <X className="h-4 w-4" />
                    </Button>
                  </div>

                  {file.status === "completed" && file.content.length > 0 && (
                    <div className="ml-6 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg border">
                      <div className="font-semibold mb-3 text-gray-700 dark:text-gray-300">é¢„è§ˆå†…å®¹</div>
                      <div className="h-32 overflow-y-auto space-y-2">
                        {file.content.slice(0, 20).map((name, i) => (
                          <div key={i} className="flex items-center gap-2 text-gray-600 dark:text-gray-400">
                            <Folder className="h-4 w-4" />
                            <span>{name}</span>
                          </div>
                        ))}
                        {file.content.length > 20 && (
                          <div className="text-gray-500 italic mt-2">... è¿˜æœ‰ {file.content.length - 20} ä¸ª</div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </CardContent>
          </Card>
        )}

        {files.some((f) => f.status === "completed") && (
          <Card className="mb-8 border-2">
            <CardContent className="pt-8">
              {isProcessing && (
                <div className="space-y-3 mb-6">
                  <div className="flex justify-between font-semibold">
                    <span>ç”Ÿæˆä¸­...</span>
                    <span>{Math.round(progress)}%</span>
                  </div>
                  <Progress value={progress} className="w-full h-3" />
                </div>
              )}

              <Button onClick={generateZip} disabled={isProcessing} className="w-full h-12 text-lg font-semibold">
                <Download className="h-5 w-5 mr-2" />
                {isProcessing ? "ç”Ÿæˆä¸­..." : "ä¸‹è½½ZIPæ–‡ä»¶"}
              </Button>
            </CardContent>
          </Card>
        )}

        <Alert className="border-2">
          <AlertCircle className="h-5 w-5" />
          <AlertDescription className="text-base">
            æ”¯æŒ .txt/.csv æ–‡ä»¶ï¼Œæ¯è¡Œä¸€ä¸ªåç§°ã€‚æœ¬åœ°å¤„ç†ï¼Œä¿æŠ¤éšç§ã€‚
          </AlertDescription>
        </Alert>

        <div className="text-center mt-12 pt-8 border-t border-gray-200 dark:border-gray-700">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            by{" "}
            <a
              href="https://itxiaozhang.com"
              target="_blank"
              rel="noopener noreferrer"
              className="text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:hover:text-gray-100 transition-colors"
            >
              ITå°ç« 
            </a>
          </p>
        </div>
      </div>
    </div>
  )
}
```

---

## æ–¹æ³•ä¸‰ï¼šæœ¬åœ° Python è„šæœ¬

### ä¼˜åŠ¿

* **æœ¬åœ°è¿è¡Œ**ï¼šæ— éœ€è”ç½‘ï¼Œé€Ÿåº¦å¿«ã€‚
* **åŠŸèƒ½ä¸°å¯Œ**ï¼šæ”¯æŒå»é‡ã€é‡å‘½åã€æ—¥å¿—ã€‚
* **é«˜åº¦å¯å®šåˆ¶**ï¼šå¯éšéœ€ä¿®æ”¹ã€‚
* **å¤šç¼–ç å…¼å®¹**ï¼š`guess_read_text` æ”¯æŒå¤šç§å¸¸è§ç¼–ç ã€‚
* **æ–‡ä»¶åæ¸…æ´—**ï¼šéæ³•å­—ç¬¦ã€Windows ä¿ç•™åã€é•¿åº¦é™åˆ¶ç­‰éƒ½å¤„ç†åˆ°ä½ã€‚
* **å¹¶å‘æ‰§è¡Œ**ï¼š`ThreadPoolExecutor` åŠ é€Ÿæ–‡ä»¶å¤¹åˆ›å»ºã€‚
* **å‚æ•°çµæ´»**ï¼šæ”¯æŒ `--exist` ç­–ç•¥ã€é‡å‘½åæ¨¡æ¿ã€æœ€å¤§é•¿åº¦ã€dry-runã€‚

### ä½¿ç”¨æ–¹æ³•

1. æ–°å»º `name.txt`ï¼Œæ¯è¡Œä¸€ä¸ªæ–‡ä»¶å¤¹åç§°ã€‚
2. ä¿å­˜è„šæœ¬ä¸º `create_dirs.py`ã€‚
3. è¿è¡Œå‘½ä»¤ï¼š

```bash
python create_dirs.py
```

### å…¨éƒ¨ä»£ç 

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
æ‰¹é‡åˆ›å»ºæ–‡ä»¶å¤¹å·¥å…·ï¼ˆå•å±‚ï¼Œç»Ÿä¸€ä¿å­˜åˆ° ./result/ï¼‰ã€‚
- ä» name.txt è¯»å–åç§°ï¼ˆä¸€è¡Œä¸€ä¸ªï¼‰ï¼Œå¤šç¼–ç å…¼å®¹ï¼Œæ¸…æ´—éæ³•å­—ç¬¦ã€‚
- åœ¨å½“å‰ç›®å½•ä¸‹çš„ result æ–‡ä»¶å¤¹ä¸­ç”Ÿæˆå¯¹åº”åŒåæ–‡ä»¶å¤¹ã€‚
"""

from __future__ import annotations
import argparse
import csv
import os
import re
import sys
import time
import unicodedata
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from pathlib import Path
from threading import Lock
from typing import List, Optional, Tuple

# ---------- å¸¸é‡ ----------
DEFAULT_INPUT = "name.txt"
DEFAULT_MAX_LEN = 200
DEFAULT_EXIST = "skip"  # skip | rename | fail
DEFAULT_RENAME_PATTERN = "{name} ({n})"
ENCODING_CANDIDATES = [
    "utf-8-sig", "utf-8", "utf-16", "utf-16-le", "utf-16-be",
    "gb18030", "cp936", "big5", "shift_jis", "cp1252", "latin-1",
]
WINDOWS_RESERVED_BASENAMES = {
    "CON", "PRN", "AUX", "NUL",
    *{f"COM{i}" for i in range(1, 10)},
    *{f"LPT{i}" for i in range(1, 10)},
}
ILLEGAL_CHARS_PATTERN = re.compile(r'[<>:"/\\|?*\x00-\x1F]')
DOTS_ONLY_PATTERN = re.compile(r"^\.+$")

# ---------- æ•°æ®ç»“æ„ ----------
@dataclass
class Item:
    line_no: int
    original: str
    cleaned: str

@dataclass
class Result:
    item: Item
    action: str   # created | skipped | renamed | error | dryrun
    final_name: Optional[str]
    final_path: Optional[str]
    status: str   # OK | ERROR
    error: Optional[str]

# ---------- å·¥å…·å‡½æ•° ----------
def guess_read_text(path: Path, forced_encoding: Optional[str] = None) -> Tuple[str, str]:
    if forced_encoding:
        return path.read_text(encoding=forced_encoding), forced_encoding
    data = path.read_bytes()
    last_err = None
    for enc in ENCODING_CANDIDATES:
        try:
            return data.decode(enc), enc
        except Exception as e:
            last_err = e
            continue
    raise RuntimeError(f"è¯»å–å¤±è´¥ï¼ŒæœªçŸ¥ç¼–ç ï¼›æœ€åé”™è¯¯ï¼š{last_err}")

def is_windows_reserved(name: str) -> bool:
    base = name.split(".", 1)[0]
    return base.upper() in WINDOWS_RESERVED_BASENAMES

def sanitize_name(raw: str, max_len: int = DEFAULT_MAX_LEN) -> str:
    s = unicodedata.normalize("NFKC", raw).strip()
    if "/" in s or "\\" in s:
        s = s.replace("/", "_").replace("\\", "_")
    if ILLEGAL_CHARS_PATTERN.search(s):
        s = ILLEGAL_CHARS_PATTERN.sub("_", s)
    s = s.rstrip(" .")
    if DOTS_ONLY_PATTERN.match(s):
        return ""
    if is_windows_reserved(s):
        s = s + "_"
    if len(s) > max_len:
        s = s[:max_len]
    return s

def parse_lines(text: str) -> List[Tuple[int, str]]:
    res = []
    for idx, line in enumerate(text.splitlines(), start=1):
        raw = line.rstrip("\r\n")
        if not raw.strip():
            continue
        if raw.lstrip().startswith("#"):
            continue
        res.append((idx, raw))
    return res

# ---------- ä¸»æ‰§è¡Œé€»è¾‘ ----------
class App:
    def __init__(self, args: argparse.Namespace):
        self.args = args
        self.base = Path.cwd() / "result"
        self.base.mkdir(exist_ok=True)  # è‡ªåŠ¨åˆ›å»º result æ–‡ä»¶å¤¹
        self.counter_ok = 0
        self.counter_skip = 0
        self.counter_err = 0
        self.counter_renamed = 0
        self.results: List[Result] = []

    def log_line(self, result: Result):
        if self.args.quiet:
            return
        name = result.final_name or result.item.cleaned or result.item.original
        if result.status == "OK":
            if result.action == "created":
                print(f"[OK] {name}")
            elif result.action == "renamed":
                print(f"[OK] {name} (renamed)")
            elif result.action == "dryrun":
                print(f"[DRY] {name}")
            elif result.action == "skipped":
                print(f"[SKIP] {name} (exists)")
        else:
            reason = (result.error or "unknown").strip()
            print(f"[ERROR] {name} ({reason})")

    def make_one(self, item: Item) -> Result:
        base = self.base
        name = item.cleaned
        target = base / name

        if self.args.dry_run:
            return Result(item, "dryrun", name, str(target), "OK", None)

        try:
            target.mkdir(parents=False, exist_ok=False)
            return Result(item, "created", name, str(target), "OK", None)
        except FileExistsError:
            if self.args.exist == "skip":
                return Result(item, "skipped", name, str(target), "OK", None)
            elif self.args.exist == "fail":
                return Result(item, "error", name, str(target), "ERROR", "already_exists")
            elif self.args.exist == "rename":
                base_name = name
                n = 2
                while True:
                    try_name = self.args.rename_pattern.format(name=base_name, n=n)
                    try_name = sanitize_name(try_name, self.args.max_name_length)
                    if not try_name:
                        return Result(item, "error", None, None, "ERROR", "rename_failed")
                    try_path = base / try_name
                    try:
                        try_path.mkdir(parents=False, exist_ok=False)
                        return Result(item, "renamed", try_name, str(try_path), "OK", None)
                    except FileExistsError:
                        n += 1
                        continue
            else:
                return Result(item, "error", name, str(target), "ERROR", "unknown_exist_strategy")
        except Exception as e:
            return Result(item, "error", name, str(target), "ERROR", str(e))

    def run(self) -> int:
        start = time.time()
        inp = Path(self.args.input)
        if not inp.exists():
            print(f"[FATAL] è¾“å…¥æ–‡ä»¶ä¸å­˜åœ¨: {inp}", file=sys.stderr)
            return 3
        try:
            text, used_enc = guess_read_text(inp, self.args.encoding)
        except Exception as e:
            print(f"[FATAL] æ— æ³•è¯»å–è¾“å…¥ï¼š{e}", file=sys.stderr)
            return 3

        for line_no, raw in parse_lines(text):
            cleaned = sanitize_name(raw, self.args.max_name_length)
            if not cleaned:
                r = Result(Item(line_no, raw, cleaned), "error", None, None, "ERROR", "invalid_or_empty")
                self.log_line(r)
                self.results.append(r)
                self.counter_err += 1
                continue
            self.results.append(Item(line_no, raw, cleaned))

        # å¹¶å‘æ‰§è¡Œ
        tasks = []
        with ThreadPoolExecutor(max_workers=self.args.max_workers) as ex:
            future_map = {ex.submit(self.make_one, it): it for it in self.results if isinstance(it, Item)}
            for fut in as_completed(future_map):
                r = fut.result()
                self.log_line(r)
                if r.status == "OK":
                    if r.action == "created":
                        self.counter_ok += 1
                    elif r.action == "skipped":
                        self.counter_skip += 1
                    elif r.action == "renamed":
                        self.counter_renamed += 1
                else:
                    self.counter_err += 1

        elapsed = time.time() - start
        total_ok = self.counter_ok + self.counter_renamed
        print(f"æ€»ç»“: æˆåŠŸ {total_ok}, è·³è¿‡ {self.counter_skip}, é”™è¯¯ {self.counter_err}, ç”¨æ—¶ {elapsed:.2f}s")
        if self.counter_err > 0 and (total_ok > 0 or self.counter_skip > 0):
            return 2
        elif self.counter_err > 0:
            return 3
        else:
            return 0

# ---------- å‚æ•° ----------
def build_argparser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="ä» name.txt æ‰¹é‡åˆ›å»ºæ–‡ä»¶å¤¹ï¼Œä¿å­˜åˆ° ./result/")
    p.add_argument("--input", default=DEFAULT_INPUT, help="è¾“å…¥æ–‡ä»¶ï¼ˆé»˜è®¤ name.txtï¼‰")
    p.add_argument("--encoding", default=None, help="æŒ‡å®šè¾“å…¥ç¼–ç ")
    p.add_argument("--exist", choices=["skip", "rename", "fail"], default=DEFAULT_EXIST, help="å·²å­˜åœ¨å¤„ç†ç­–ç•¥ï¼ˆé»˜è®¤ skipï¼‰")
    p.add_argument("--rename-pattern", default=DEFAULT_RENAME_PATTERN, help="é‡å‘½åæ¨¡æ¿ï¼Œå« {name} å’Œ {n}")
    p.add_argument("--max-name-length", type=int, default=DEFAULT_MAX_LEN, help="æ–‡ä»¶å¤¹åæœ€å¤§é•¿åº¦ï¼ˆé»˜è®¤200ï¼‰")
    default_workers = min(8, (os.cpu_count() or 2) * 4)
    p.add_argument("--max-workers", type=int, default=default_workers, help=f"å¹¶å‘çº¿ç¨‹æ•°ï¼ˆé»˜è®¤ {default_workers}ï¼‰")
    p.add_argument("--dry-run", action="store_true", help="ä»…é¢„æ¼”ï¼Œä¸åˆ›å»ºç›®å½•")
    p.add_argument("--quiet", action="store_true", help="ä»…è¾“å‡ºæ±‡æ€»")
    return p

def main(argv: Optional[List[str]] = None) -> int:
    args = build_argparser().parse_args(argv)
    app = App(args)
    code = app.run()
    return code

if __name__ == "__main__":
    sys.exit(main())
```

## è§†é¢‘ç‰ˆæœ¬

* [å“”å“©å“”å“©](https://space.bilibili.com/3546607630944387)
* [YouTube](https://www.youtube.com/@itxiaozhang)

---
â–¶ å¦‚æœæ‚¨éœ€è¦è¿œç¨‹ç”µè„‘ç»´ä¿®æˆ–è€…ç¼–ç¨‹å¼€å‘ï¼Œè¯·[åŠ æˆ‘å¾®ä¿¡](https://itxiaozhang.netlify.app/)å’¨è¯¢ã€‚ 
â–¶ æœ¬ç½‘ç«™çš„éƒ¨åˆ†å†…å®¹å¯èƒ½æ¥æºäºç½‘ç»œï¼Œä»…ä¾›å¤§å®¶å­¦ä¹ ä¸å‚è€ƒï¼Œå¦‚æœ‰ä¾µæƒè¯·è”ç³»æˆ‘æ ¸å®åˆ é™¤ã€‚  
â–¶ **æˆ‘æ˜¯å°ç« ï¼Œç›®å‰å…¨èŒæä¾›ç”µè„‘ç»´ä¿®å’ŒITå’¨è¯¢æœåŠ¡ã€‚å¦‚æœæ‚¨æœ‰ä»»ä½•ç”µè„‘ç›¸å…³çš„é—®é¢˜ï¼Œéƒ½å¯ä»¥é—®æˆ‘å™¢ã€‚**  
